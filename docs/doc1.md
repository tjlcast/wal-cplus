# WAL (Write-Ahead Log) 核心解读

## 1. 基本概念
WAL (Write-Ahead Log) 是一种持久化机制，核心思想是**在数据修改前先写入日志**，确保数据不会丢失。

## 2. 核心组件

```
+---------------------+
|       WAL类         |
+---------------------+
| - segments_         |--> 段文件列表
| - scache_           |--> 段缓存(LRU)
| - first_index_      |--> 第一个日志索引
| - last_index_       |--> 最后一个日志索引
| - sfile_            |--> 当前段文件句柄
+---------------------+
```

## 3. 核心处理机制

### 3.1 写入流程

```
1. 检查状态 (corrupt_, closed_)
2. 将数据加入批量写入缓冲区 (wbatch_)
3. 实际写入流程:
   +-----------------------+
   | 检查索引连续性        |
   | 检查当前段是否已满    |
   | 若满则创建新段        |
   | 将数据编码后写入缓冲区|
   | 同步到磁盘            |
   +-----------------------+
```

### 3.2 读取流程

```
1. 检查状态和索引范围
2. 查找对应段文件:
   +-------------------------+
   | 先检查最后段            |
   | 再检查缓存(LRU)         |
   | 最后在段列表中二分查找  |
   +-------------------------+
3. 从段文件中读取数据并解码
```

### 3.3 段文件管理

```
段文件命名格式:
00000000000000000001       # 常规段
00000000000000000005.START # 截断前端时临时文件
00000000000000000003.END   # 截断后端时临时文件

段文件内部结构:
+----------------+----------------+----------------+
| 条目1          | 条目2          | 条目3          |
+----------------+----------------+----------------+
每个条目可以是:
- JSON格式: {"index":"1","data":"..."}
- 二进制格式: [varint长度][原始数据]
```

## 4. 关键操作示意图

### 4.1 写入操作

```
[Write] --> [Batch缓存] --> [当前段]
                              |
                              v
                     [段满?] --是--> [创建新段]
                              |
                              否
                              v
                     [追加数据] --> [Sync]
```

### 4.2 截断前端(TruncateFront)

```
原始段:
[段1:1-100][段2:101-200][段3:201-300]

截断到150:
1. 找到段2(101-200)
2. 保留150-200的数据
3. 创建临时文件150.START
4. 删除段1和段2
5. 重命名为150
6. 更新段列表为[段150:150-200][段3:201-300]
```

### 4.3 截断后端(TruncateBack)

```
原始段:
[段1:1-100][段2:101-200][段3:201-300]

截断到250:
1. 找到段3(201-300)
2. 保留201-250的数据
3. 创建临时文件201.END
4. 删除段3
5. 重命名为201
6. 更新段列表为[段1:1-100][段2:101-200][段201:201-250]
```

## 5. 关键数据结构

### 5.1 Segment结构

```cpp
struct Segment {
    uint64_t index;                     // 段起始索引
    std::string path;                   // 文件路径
    std::vector<uint8_t> ebuf;         // 条目缓冲区
    std::vector<std::pair<size_t, size_t>> epos; // 条目位置(起始,结束)
};
```

### 5.2 缓存管理

```
LRU缓存机制:
+----------------+   +----------------+   +----------------+
| 段索引2        |   | 段索引1        |   | 段索引3        |
| (最近使用)     |   |                |   | (最久未使用)   |
+----------------+   +----------------+   +----------------+
        ^                    ^                    |
        |                    |                    v
        +--------------------+             [下次被淘汰]
```

## 6. 故障恢复机制

```
启动时检查:
1. 扫描目录所有段文件
2. 处理.START/.END临时文件:
   - 有.START: 删除之前的所有段，重命名
   - 有.END: 删除之后的所有段，重命名
3. 验证段文件连续性
4. 加载最后段的索引
```

## 7. 性能优化

1. **批量写入**：使用Batch结构累积多次写入
2. **段缓存**：LRU缓存最近访问的段
3. **异步同步**：通过no_sync选项控制
4. **内存映射**：二进制格式避免数据拷贝(no_copy选项)

这个WAL实现提供了可靠的持久化机制，适合作为数据库或分布式系统的底层日志组件。其核心特点是分段存储、索引快速查找和原子性操作保证。