## `segments_`、`lru_order_` 和 `scache_` 的协作机制示意图

这三个数据结构主要在 **段缓存管理** 和 **读写操作** 中协作，以下是它们的交互流程：

### 1. 初始状态
```
segments_: [段1, 段2, 段3]  
scache_: {}  
lru_order_: []
```

### 2. 读取操作触发缓存加载 (`LoadSegment`)
```
[读索引50] → 发现位于段2 → 更新缓存:
           +---------------------+
scache_:    | 2: 段2              |
           +---------------------+
lru_order_: [2]
```

### 3. 再次读取触发LRU更新
```
[读索引120] → 位于段3 → 更新缓存:
           +---------------------+
scache_:    | 2: 段2              |
           | 3: 段3 (最新)       |
           +---------------------+
lru_order_: [2, 3] (3是最近使用的)

[读索引50] → 命中缓存 → 调整LRU顺序:
           +---------------------+
scache_:    | 3: 段3              |
           | 2: 段2 (最新)       |
           +---------------------+
lru_order_: [3, 2] (2被提到前面)
```

### 4. 缓存淘汰场景
```
假设缓存大小=2，新读取段1:
           +---------------------+
scache_:    | 2: 段2 (最旧)       | ← 被淘汰
           | 1: 段1 (新增)        |
           | 3: 段3              |
           +---------------------+
lru_order_: [3, 1] (原[3,2] → 移除2)
```

### 5. 段变更操作（如截断）的协作
```
[TruncateFront] → 删除段1 → 同步清理缓存:
           +---------------------+
segments_: [段2, 段3]            |
           +---------------------+
scache_:    | 3: 段3              | ← 自动移除段1相关条目
           +---------------------+
lru_order_: [3]
```

### 协作流程图解
```
+-------------------+     +-------------------+     +-------------------+
|    segments_      |     |     scache_       |     |    lru_order_     |
| (所有段文件列表)  | ←→  | (缓存的段映射表)  | ←→  | (最近使用顺序)    |
+-------------------+     +-------------------+     +-------------------+
        ↑                         ↑                         |
        |                         |                         |
        | 1. 查找段位置           | 3. 更新访问顺序         |
        |                         |                         ↓
        +-------------------------+-------------------> [LRU淘汰]
              2. 加载段到缓存
```

### 关键协作点说明
1. **读操作**  
   - 先在`scache_`中查找（通过`lru_order_`判断热点）
   - 未命中时从`segments_`加载，并更新缓存

2. **写操作/段切换**  
   - 新段会通过`PushCache`加入`scache_`和`lru_order_`

3. **截断操作**  
   - 修改`segments_`后调用`ClearCacheInternal`同步清理失效缓存

4. **缓存淘汰**  
   - 当`scache_.size() > cache_size`时，按`lru_order_`顺序移除最旧条目

这种设计确保了高频访问的段保持在内存中，同时通过LRU机制自动管理内存占用。


在 `WAL` 的实现中，当从 `scache_`（段缓存）驱逐一个 `Segment` 时，**不会释放 `Segment` 的核心数据**，而是会保留其元信息，仅释放 **内存中的条目数据缓冲**。以下是具体细节：

---

### **1. 驱逐时释放的资源**
#### （1）`Segment` 结构的关键成员
```cpp
struct Segment {
    uint64_t index;                     // 起始索引（保留）
    std::string path;                   // 文件路径（保留）
    std::vector<uint8_t> ebuf;          // 条目数据缓冲区（被清空）
    std::vector<std::pair<size_t, size_t>> epos;  // 条目位置信息（被清空）
};
```

#### （2）实际释放的资源
| 成员           | 是否释放 | 原因                                                                  |
| -------------- | -------- | --------------------------------------------------------------------- |
| `ebuf`         | ✅ 是     | 存储实际的日志条目数据（可能很大），从缓存移除时会调用 `ebuf.clear()` |
| `epos`         | ✅ 是     | 条目位置索引数据，随 `ebuf` 一起清空                                  |
| `index`/`path` | ❌ 否     | 元信息需保留，后续仍可能通过 `segments_` 重新加载                     |

---

### **2. 驱逐流程示意图**
```
[缓存驱逐触发]
     |
     ↓
+------------------+
| 从 scache_ 移除   | → 清除该 Segment 在 scache_ 中的键值对
+------------------+
     |
     ↓
+------------------+
| 从 lru_order_ 移除 | → 移除对应的段索引（维护 LRU 顺序）
+------------------+
     |
     ↓
+------------------+
| 调用 ebuf.clear() | → 释放内存中的条目数据缓冲区
| 调用 epos.clear() | → 释放条目位置索引
+------------------+
```

---

### **3. 与 `segments_` 的关系**
- **`segments_` 不受影响**：  
  它是所有段的全局列表，缓存驱逐仅释放内存数据，不会删除磁盘文件或移除 `segments_` 中的条目。
- **重新加载机制**：  
  若再次访问被驱逐的段，会通过 `segments_` 找到路径，重新从磁盘加载 `ebuf` 和 `epos`。

---

### **4. 设计意图**
1. **内存优化**：  
   避免长期占用大量内存，仅缓存活跃段的条目数据。
2. **快速恢复**：  
   保留 `index` 和 `path` 使得重新加载时无需重新扫描目录。
3. **一致性保证**：  
   即使缓存被驱逐，仍能通过 `segments_` 和磁盘文件恢复完整数据。

---

### **5. 示例场景**
假设缓存已满，新访问段4触发对段1的驱逐：
```cpp
// 驱逐前
scache_ = {1: Segment1{ebuf=[...], epos=[...]}, 2: Segment2{...}};
lru_order_ = [1, 2];

// 访问段3（未缓存）
LoadSegment(3); 

// 驱逐段1后的状态
scache_ = {2: Segment2{...}, 3: Segment3{ebuf=[...], epos=[...]}};
lru_order_ = [2, 3];
// Segment1 的 ebuf 和 epos 被清空，但 index/path 仍保留在 segments_ 中
```

通过这种设计，WAL 在内存和磁盘之间实现了高效的平衡。